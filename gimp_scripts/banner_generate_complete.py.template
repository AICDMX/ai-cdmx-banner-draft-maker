import sys
import gi
gi.require_version('Gimp', '3.0')
from gi.repository import Gimp, Gio

pdb = Gimp.get_pdb()

print("Banner generation started...")

# Load template
try:
    proc = pdb.lookup_procedure("gimp-file-load")
    config = proc.create_config()
    file_obj = Gio.File.new_for_path("{template_path}")
    config.set_property("file", file_obj)
    result = proc.run(config)

    # Extract image from ValueArray (status at index 0, image at index 1)
    image = result.index(1) if hasattr(result, 'index') else result
except Exception as e:
    print(f"Error loading template: {{e}}")
    image = None

# Build layer dictionary (including layers in groups)
layers = {{}}
def collect_layers(parent):
    """Recursively collect all layers including those in groups"""
    collected = {{}}
    try:
        for item in parent.get_layers():
            collected[item.get_name()] = item
            # If it's a group (layer group), recurse into it
            try:
                if item.is_group():
                    # Try different methods to get children
                    children = None
                    try:
                        # Try get_children() first (GIMP 3.0)
                        children = item.get_children()
                    except:
                        try:
                            # Try get_layers() (alternative)
                            children = item.get_layers()
                        except:
                            pass

                    if children:
                        for child in children:
                            collected[child.get_name()] = child
            except AttributeError:
                pass
    except Exception as e:
        print(f"Error in collect_layers: {{e}}")
    return collected

if image:
    try:
        layers = collect_layers(image)
    except Exception as e:
        print(f"Error collecting layers: {{e}}")

# Update text layers - use gimp-item-edit-text to preserve formatting
text_fields = {{
    "Title1": "{title1}",
    "Title2": "{title2}",
    "SpeakerName": "{speaker_name}",
    "SpeakerTitle": "{speaker_title}",
    "Date": "{date}",
    "Time": "{time}"
}}

for layer_name, text_value in text_fields.items():
    if layer_name in layers:
        try:
            layer = layers[layer_name]

            # Try using gimp-item-edit-text which preserves formatting
            proc = pdb.lookup_procedure("gimp-item-edit-text")
            if proc:
                try:
                    config = proc.create_config()
                    config.set_property("item", layer)
                    config.set_property("text", text_value)
                    proc.run(config)
                except Exception as e:
                    pass
            else:
                pass

        except Exception as e:
            pass
    else:
        pass

# Handle speaker photo if SpeakerPhoto layer exists
# This section is conditionally executed based on template structure
if "SpeakerPhoto" in layers:
    try:
        photo_layer = layers["SpeakerPhoto"]

        # Load the photo as a new image using PDB procedure
        proc = pdb.lookup_procedure("gimp-file-load")
        if proc:
            config = proc.create_config()
            file_obj = Gio.File.new_for_path("{photo_path}")
            config.set_property("file", file_obj)
            photo_result = proc.run(config)
            try:
                # Extract image from result - it's at index 1 like in template loading
                photo_image = photo_result.index(1) if hasattr(photo_result, 'index') else photo_result
            except (IndexError, AttributeError):
                photo_image = None
        else:
            photo_image = None

        # Check if photo was loaded successfully
        if photo_image is None:
            raise Exception("Failed to load photo image")

        # Get active layer from photo using GIMP 3.0 API
        layers_list = photo_image.get_layers()
        if not layers_list:
            raise Exception("Photo image has no layers")
        photo_drawable = layers_list[0]

        # Get the dimensions of the placeholder layer using GIMP 3.0 API
        placeholder_width = photo_layer.get_width()
        placeholder_height = photo_layer.get_height()
        _, placeholder_x, placeholder_y = photo_layer.get_offsets()

        # Get photo dimensions
        photo_width = photo_drawable.get_width()
        photo_height = photo_drawable.get_height()

        # Scale the photo to fill the placeholder (maintaining aspect ratio)
        # Using max instead of min ensures the image covers the entire area
        scale_w = float(placeholder_width) / photo_width
        scale_h = float(placeholder_height) / photo_height
        scale = max(scale_w, scale_h)

        new_width = int(photo_width * scale)
        new_height = int(photo_height * scale)

        # Scale image using GIMP 3.0 API
        photo_image.scale(new_width, new_height)

        # Get active layer again after scaling
        layers_list = photo_image.get_layers()
        if not layers_list:
            raise Exception("Photo image has no layers after scaling")
        photo_drawable = layers_list[0]

        # Copy the photo layer to the main image using GIMP 3.0 API
        new_layer = Gimp.Layer.new_from_drawable(photo_drawable, image)
        if new_layer is None:
            raise Exception("Failed to create layer from photo drawable")

        # Resize the layer to match the scaled dimensions (layer should fit the scaled image)
        new_layer.scale(new_width, new_height)

        # Insert layer just below the SpeakerPhoto placeholder layer
        # Get the parent of the SpeakerPhoto layer (handles groups)
        parent = photo_layer.get_parent()

        # Insert the layer - try to insert into the same group
        if parent:
            # Try to find the index of the photo_layer within parent
            try:
                # Try get_children() for GroupLayer
                children = parent.get_children()
                photo_index = None
                if children:
                    for i, child in enumerate(children):
                        if child.get_name() == photo_layer.get_name():
                            photo_index = i
                            break

                if photo_index is not None:
                    image.insert_layer(new_layer, parent, photo_index + 1)
                else:
                    # Fallback: insert at position 0 in the group
                    image.insert_layer(new_layer, parent, 0)
            except:
                # If get_children() fails, try inserting at root
                image.insert_layer(new_layer, None, 0)
        else:
            # If no parent, insert at position 0 at root
            image.insert_layer(new_layer, None, 0)

        # Position the photo at the placeholder location
        # If the image is larger than the placeholder, center it so it fills the area
        offset_x = placeholder_x + (placeholder_width - new_width) // 2
        offset_y = placeholder_y + (placeholder_height - new_height) // 2

        new_layer.set_offsets(offset_x, offset_y)

        # Set composite mode to "Clip to Backdrop"
        new_layer.set_blend_space(Gimp.LayerColorSpace.AUTO)
        new_layer.set_composite_mode(Gimp.LayerCompositeMode.CLIP_TO_BACKDROP)

        # Rename the new layer
        new_layer.set_name("SpeakerPhoto_Inserted")

        # Delete the photo image
        proc = pdb.lookup_procedure("gimp-image-delete")
        config = proc.create_config()
        config.set_property("image", photo_image)
        proc.run(config)
    except Exception as e:
        print("Warning: Could not insert photo: " + str(e))

# Save as XCF
if image:
    try:
        # Try multiple save procedures
        proc = (pdb.lookup_procedure("gimp-image-save-as") or
                pdb.lookup_procedure("gimp-xcf-save") or
                pdb.lookup_procedure("file-xcf-save"))

        if proc:
            config = proc.create_config()
            config.set_property("image", image)
            file_obj = Gio.File.new_for_path("{output_xcf}")
            config.set_property("file", file_obj)
            proc.run(config)
    except Exception as e:
        print(f"Warning: XCF save failed: {{e}}")

# Flatten and save as JPG
if image:
    try:
        print("Creating duplicate image for flattening...")
        proc = pdb.lookup_procedure("gimp-image-duplicate")
        if proc:
            config = proc.create_config()
            config.set_property("image", image)
            result = proc.run(config)

            # Extract duplicated image
            flat_image = result.index(1) if hasattr(result, 'index') else result
            print(f"Duplicate created: {{flat_image}}")

            # Flatten
            print("Flattening image...")
            proc = pdb.lookup_procedure("gimp-image-flatten")
            if proc and flat_image:
                config = proc.create_config()
                config.set_property("image", flat_image)
                proc.run(config)
                print("Image flattened successfully")

                # Save as JPG
                try:
                    # Try multiple possible procedure names for GIMP 3.0
                    procedures_to_try = [
                        "gimp-file-save",
                        "gimp-image-export-as",
                        "file-jpeg-save",
                        "file-jpeg-save-defaults",
                        "jpeg-save"
                    ]

                    proc = None
                    for pname in procedures_to_try:
                        proc = pdb.lookup_procedure(pname)
                        if proc:
                            break

                    if proc:
                        config = proc.create_config()
                        config.set_property("image", flat_image)
                        file_obj = Gio.File.new_for_path("{output_jpg}")
                        config.set_property("file", file_obj)

                        # Try to set run-mode if available
                        try:
                            config.set_property("run-mode", Gimp.RunMode.NONINTERACTIVE)
                        except:
                            pass

                        proc.run(config)
                    else:
                        print("Warning: No JPG export procedure found")
                except Exception as e:
                    print("Warning: JPG save failed: " + str(e))

                # Clean up flat image
                print("Cleaning up duplicate image...")
                try:
                    proc = pdb.lookup_procedure("gimp-image-delete")
                    if proc:
                        config = proc.create_config()
                        config.set_property("image", flat_image)
                        proc.run(config)
                except:
                    pass
        else:
            print("ERROR: gimp-image-duplicate procedure not found!")
    except Exception as e:
        print(f"ERROR: JPG processing failed: {{e}}")
        import traceback
        traceback.print_exc()

# Clean up original image
try:
    proc = pdb.lookup_procedure("gimp-image-delete")
    if proc and image:
        config = proc.create_config()
        config.set_property("image", image)
        proc.run(config)
except:
    pass

